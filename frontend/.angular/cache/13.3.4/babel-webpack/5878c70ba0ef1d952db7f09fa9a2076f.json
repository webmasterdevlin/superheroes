{"ast":null,"code":"import deepmerge from 'deepmerge'; // Cannot import from the @ngrx/store package due to a module resolution issue.\n// See Issue #206.\n\nconst INIT_ACTION = '@ngrx/store/init';\nconst UPDATE_ACTION = '@ngrx/store/update-reducers';\nconst detectDate = /(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})/; // correctly parse dates from local storage\n\nconst dateReviver = (_key, value) => {\n  if (typeof value === 'string' && detectDate.test(value)) {\n    return new Date(value);\n  }\n\n  return value;\n};\n\nconst dummyReviver = (_key, value) => value;\n\nconst checkIsBrowserEnv = () => {\n  return typeof window !== 'undefined';\n};\n\nconst validateStateKeys = keys => {\n  return keys.map(key => {\n    let attr = key;\n\n    if (typeof key === 'object') {\n      attr = Object.keys(key)[0];\n    }\n\n    if (typeof attr !== 'string') {\n      throw new TypeError(`localStorageSync Unknown Parameter Type: ` + `Expected type of string, got ${typeof attr}`);\n    }\n\n    return key;\n  });\n};\n\nconst rehydrateApplicationState = (keys, storage, storageKeySerializer, restoreDates) => {\n  return keys.reduce((acc, curr) => {\n    let key = curr;\n    let reviver = restoreDates ? dateReviver : dummyReviver;\n    let deserialize;\n    let decrypt;\n\n    if (typeof key === 'object') {\n      key = Object.keys(key)[0]; // use the custom reviver function\n\n      if (typeof curr[key] === 'function') {\n        reviver = curr[key];\n      } else {\n        // use custom reviver function if available\n        if (curr[key].reviver) {\n          reviver = curr[key].reviver;\n        } // use custom serialize function if available\n\n\n        if (curr[key].deserialize) {\n          deserialize = curr[key].deserialize;\n        }\n      } // Ensure that encrypt and decrypt functions are both present\n\n\n      if (curr[key].encrypt && curr[key].decrypt) {\n        if (typeof curr[key].encrypt === 'function' && typeof curr[key].decrypt === 'function') {\n          decrypt = curr[key].decrypt;\n        } else {\n          console.error(`Either encrypt or decrypt is not a function on '${curr[key]}' key object.`);\n        }\n      } else if (curr[key].encrypt || curr[key].decrypt) {\n        // Let know that one of the encryption functions is not provided\n        console.error(`Either encrypt or decrypt function is not present on '${curr[key]}' key object.`);\n      }\n    }\n\n    if (storage !== undefined) {\n      let stateSlice = storage.getItem(storageKeySerializer(key));\n\n      if (stateSlice) {\n        // Use provided decrypt function\n        if (decrypt) {\n          stateSlice = decrypt(stateSlice);\n        }\n\n        const isObjectRegex = new RegExp('{|\\\\[');\n        let raw = stateSlice;\n\n        if (stateSlice === 'null' || stateSlice === 'true' || stateSlice === 'false' || isObjectRegex.test(stateSlice.charAt(0))) {\n          raw = JSON.parse(stateSlice, reviver);\n        }\n\n        return Object.assign({}, acc, {\n          [key]: deserialize ? deserialize(raw) : raw\n        });\n      }\n    }\n\n    return acc;\n  }, {});\n}; // Recursively traverse all properties of the existing slice as defined by the `filter` argument,\n// and output the new object with extraneous properties removed.\n\n\nfunction createStateSlice(existingSlice, filter) {\n  return filter.reduce((memo, attr) => {\n    if (typeof attr === 'string' || typeof attr === 'number') {\n      const value = existingSlice === null || existingSlice === void 0 ? void 0 : existingSlice[attr];\n\n      if (value !== undefined) {\n        memo[attr] = value;\n      }\n    } else {\n      for (const key in attr) {\n        if (Object.prototype.hasOwnProperty.call(attr, key)) {\n          const element = attr[key];\n          memo[key] = createStateSlice(existingSlice[key], element);\n        }\n      }\n    }\n\n    return memo;\n  }, {});\n}\n\nconst syncStateUpdate = (state, keys, storage, storageKeySerializer, removeOnUndefined, syncCondition) => {\n  if (syncCondition) {\n    try {\n      if (syncCondition(state) !== true) {\n        return;\n      }\n    } catch (e) {\n      // Treat TypeError as do not sync\n      if (e instanceof TypeError) {\n        return;\n      }\n\n      throw e;\n    }\n  }\n\n  keys.forEach(key => {\n    let stateSlice = state[key];\n    let replacer;\n    let space;\n    let encrypt;\n\n    if (typeof key === 'object') {\n      let name = Object.keys(key)[0];\n      stateSlice = state[name];\n\n      if (typeof stateSlice !== 'undefined' && key[name]) {\n        // use serialize function if specified.\n        if (key[name].serialize) {\n          stateSlice = key[name].serialize(stateSlice);\n        } else {\n          // if serialize function is not specified filter on fields if an array has been provided.\n          let filter;\n\n          if (key[name].reduce) {\n            filter = key[name];\n          } else if (key[name].filter) {\n            filter = key[name].filter;\n          }\n\n          if (filter) {\n            stateSlice = createStateSlice(stateSlice, filter);\n          } // Check if encrypt and decrypt are present, also checked at this#rehydrateApplicationState()\n\n\n          if (key[name].encrypt && key[name].decrypt) {\n            if (typeof key[name].encrypt === 'function') {\n              encrypt = key[name].encrypt;\n            }\n          } else if (key[name].encrypt || key[name].decrypt) {\n            // If one of those is not present, then let know that one is missing\n            console.error(`Either encrypt or decrypt function is not present on '${key[name]}' key object.`);\n          }\n        }\n        /*\n        Replacer and space arguments to pass to JSON.stringify.\n        If these fields don't exist, undefined will be passed.\n        */\n\n\n        replacer = key[name].replacer;\n        space = key[name].space;\n      }\n\n      key = name;\n    }\n\n    if (typeof stateSlice !== 'undefined' && storage !== undefined) {\n      try {\n        if (encrypt) {\n          // ensure that a string message is passed\n          stateSlice = encrypt(typeof stateSlice === 'string' ? stateSlice : JSON.stringify(stateSlice, replacer, space));\n        }\n\n        storage.setItem(storageKeySerializer(key), typeof stateSlice === 'string' ? stateSlice : JSON.stringify(stateSlice, replacer, space));\n      } catch (e) {\n        console.warn('Unable to save state to localStorage:', e);\n      }\n    } else if (typeof stateSlice === 'undefined' && removeOnUndefined && storage !== undefined) {\n      try {\n        storage.removeItem(storageKeySerializer(key));\n      } catch (e) {\n        console.warn(`Exception on removing/cleaning undefined '${key}' state`, e);\n      }\n    }\n  });\n}; // Default merge strategy is a full deep merge.\n\n\nconst defaultMergeReducer = (state, rehydratedState, action) => {\n  if ((action.type === INIT_ACTION || action.type === UPDATE_ACTION) && rehydratedState) {\n    const overwriteMerge = (destinationArray, sourceArray, options) => sourceArray;\n\n    const options = {\n      arrayMerge: overwriteMerge\n    };\n    state = deepmerge(state, rehydratedState, options);\n  }\n\n  return state;\n};\n\nconst localStorageSync = config => reducer => {\n  if (config.storage === undefined && !config.checkStorageAvailability || config.checkStorageAvailability && checkIsBrowserEnv()) {\n    config.storage = localStorage || window.localStorage;\n  }\n\n  if (config.storageKeySerializer === undefined) {\n    config.storageKeySerializer = key => key;\n  }\n\n  if (config.restoreDates === undefined) {\n    config.restoreDates = true;\n  } // Use default merge reducer.\n\n\n  let mergeReducer = config.mergeReducer;\n\n  if (mergeReducer === undefined || typeof mergeReducer !== 'function') {\n    mergeReducer = defaultMergeReducer;\n  }\n\n  const stateKeys = validateStateKeys(config.keys);\n  const rehydratedState = config.rehydrate ? rehydrateApplicationState(stateKeys, config.storage, config.storageKeySerializer, config.restoreDates) : undefined;\n  return function (state, action) {\n    let nextState; // If state arrives undefined, we need to let it through the supplied reducer\n    // in order to get a complete state as defined by user\n\n    if (action.type === INIT_ACTION && !state) {\n      nextState = reducer(state, action);\n    } else {\n      nextState = Object.assign({}, state);\n    } // Merge the store state with the rehydrated state using\n    // either a user-defined reducer or the default.\n\n\n    nextState = mergeReducer(nextState, rehydratedState, action);\n    nextState = reducer(nextState, action);\n\n    if (action.type !== INIT_ACTION) {\n      syncStateUpdate(nextState, stateKeys, config.storage, config.storageKeySerializer, config.removeOnUndefined, config.syncCondition);\n    }\n\n    return nextState;\n  };\n};\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { dateReviver, defaultMergeReducer, localStorageSync, rehydrateApplicationState, syncStateUpdate }; //# sourceMappingURL=ngrx-store-localstorage.mjs.map","map":null,"metadata":{},"sourceType":"module"}